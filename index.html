<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Territory Map Viewer</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #111827;
            --muted: #9ca3af;
            --accent: #22c55e;
            --outline: #1f2937;
        }
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            font-family: "Inter", system-ui, -apple-system, sans-serif;
            background: radial-gradient(circle at 20% 20%, #1f2937, #0b1021 50%);
            color: #e5e7eb;
            min-height: 100vh;
            display: flex;
            align-items: stretch;
            justify-content: center;
            padding: 24px;
        }
        .shell {
            width: min(1200px, 100%);
            background: #0b1222;
            border: 1px solid #16213d;
            border-radius: 16px;
            box-shadow: 0 30px 120px rgba(0, 0, 0, 0.45);
            overflow: hidden;
            display: grid;
            grid-template-rows: auto 1fr auto;
        }
        header {
            padding: 16px 20px;
            border-bottom: 1px solid #16213d;
            display: flex;
            align-items: center;
            gap: 12px;
            background: linear-gradient(90deg, #0d1528, #0b1222);
        }
        header h1 {
            font-size: 18px;
            margin: 0;
        }
        header small {
            color: var(--muted);
        }
        .main {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 0;
            min-height: 640px;
        }
        .map-panel {
            background: #0f172a;
            border-right: 1px solid #16213d;
            display: grid;
            grid-template-rows: auto 1fr;
        }
        .controls {
            padding: 16px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            border-bottom: 1px solid #16213d;
            background: #0d1426;
        }
        .controls label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 4px;
        }
        .controls input,
        .controls button,
        .controls select {
            width: 100%;
            background: #0b1222;
            border: 1px solid #1f2937;
            color: #e5e7eb;
            padding: 10px 12px;
            border-radius: 10px;
            font-size: 14px;
        }
        .controls button {
            background: linear-gradient(90deg, #22c55e, #16a34a);
            color: #0b1021;
            font-weight: 700;
            cursor: pointer;
            border: none;
            box-shadow: 0 12px 30px rgba(34, 197, 94, 0.2);
        }
        .controls button.secondary {
            background: #111827;
            color: #e5e7eb;
            border: 1px solid #1f2937;
            box-shadow: none;
        }
        .map-wrap {
            position: relative;
        }
        svg {
            width: 100%;
            height: 100%;
        }
        .legend {
            position: absolute;
            right: 16px;
            top: 16px;
            background: rgba(12, 18, 34, 0.9);
            border: 1px solid #1f2937;
            border-radius: 10px;
            padding: 12px;
            backdrop-filter: blur(6px);
        }
        .legend h4 {
            margin: 0 0 8px;
            font-size: 12px;
            color: var(--muted);
            letter-spacing: 0.08em;
        }
        .legend ul {
            list-style: none;
            margin: 0;
            padding: 0;
            display: grid;
            gap: 6px;
        }
        .legend li {
            display: grid;
            grid-template-columns: 18px 1fr;
            gap: 8px;
            align-items: center;
            font-size: 13px;
        }
        .legend span.swatch {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            display: inline-block;
            border: 1px solid #16213d;
        }
        .info-panel {
            background: #0d1426;
            padding: 20px;
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 16px;
        }
        .card {
            background: #0b1222;
            border: 1px solid #1f2937;
            border-radius: 12px;
            padding: 14px 16px;
        }
        .card h3 {
            margin: 0 0 6px;
            font-size: 15px;
        }
        .muted {
            color: var(--muted);
            font-size: 13px;
        }
        .pill {
            display: inline-block;
            background: #111827;
            border: 1px solid #1f2937;
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 12px;
            color: #cbd5e1;
            margin-right: 8px;
        }
        .selection-details strong {
            color: #22c55e;
        }
        .copy-btn {
            margin-top: 10px;
            background: #111827;
            color: #e5e7eb;
            border: 1px solid #1f2937;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
        }
        footer {
            border-top: 1px solid #16213d;
            padding: 16px 20px;
            background: #0d1426;
            font-size: 13px;
            color: var(--muted);
        }
        .state {
            fill: #0c172e;
            stroke: #1f2937;
            stroke-width: 0.75px;
        }
        .territory {
            stroke: #0b1021;
            stroke-width: 1.5px;
            fill-opacity: 0.28;
        }
        .territory-label {
            font-size: 11px;
            fill: #e5e7eb;
            text-anchor: middle;
            pointer-events: none;
            font-weight: 700;
            paint-order: stroke;
            stroke: #0b1021;
            stroke-width: 3px;
        }
        .selected {
            stroke: #fbbf24;
            stroke-width: 2.5px;
        }
        .point {
            fill: #fbbf24;
            stroke: #111827;
            stroke-width: 1px;
        }
        .status {
            color: #22c55e;
        }
        .readme {
            background: #0b1222;
            border: 1px dashed #1f2937;
            padding: 12px;
            border-radius: 10px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="shell">
        <header>
            <div>
                <h1>US State + Territory Viewer</h1>
                <small>Local assets, offline geocoder, and copyable assignments</small>
            </div>
        </header>
        <div class="main">
            <section class="map-panel">
                <div class="controls">
                    <div>
                        <label for="search">Search address or territory</label>
                        <input list="search-options" id="search" name="search" placeholder="Start typing..." />
                        <datalist id="search-options"></datalist>
                    </div>
                    <div>
                        <label for="lat">Latitude</label>
                        <input type="number" step="0.0001" id="lat" placeholder="e.g. 37.422" />
                    </div>
                    <div>
                        <label for="lon">Longitude</label>
                        <input type="number" step="0.0001" id="lon" placeholder="e.g. -122.084" />
                    </div>
                    <div>
                        <label for="go">&nbsp;</label>
                        <button id="geocode">Locate</button>
                    </div>
                    <div>
                        <label for="reset">&nbsp;</label>
                        <button id="reset" class="secondary">Reset view</button>
                    </div>
                </div>
                <div class="map-wrap">
                    <svg id="map" viewBox="0 0 960 600"></svg>
                    <div class="legend" id="legend"></div>
                </div>
            </section>
            <aside class="info-panel">
                <div class="card selection-details">
                    <h3>Selection</h3>
                    <div id="selection">Click a state or territory, or search above.</div>
                    <button class="copy-btn" id="copy">Copy details</button>
                </div>
                <div class="card">
                    <h3>Geocoder status</h3>
                    <p class="muted">Prebuilt address index ships locally. You can also paste lat/lon to drop a point anywhere in the US map.</p>
                    <p class="status" id="status">Ready.</p>
                </div>
                <div class="card readme">
                    <h3>How to update data</h3>
                    <ol class="muted">
                        <li>Edit <code>data/map-data.json</code> to change the TopoJSON or territories.</li>
                        <li>Territories follow GeoJSON Polygon coordinates; update <code>color</code>, <code>owner</code>, and labels as needed.</li>
                        <li>Append to <code>geocoder.addresses</code> with new address-to-coordinate entries.</li>
                        <li>Refresh the page; all assets are loaded locally.</li>
                    </ol>
                </div>
            </aside>
        </div>
        <footer>
            Built with local D3 + TopoJSON. Click to inspect states or territories, search to zoom to a location, and use the Copy button to grab assignment text.
        </footer>
    </div>
    <script src="libs/d3.min.js"></script>
    <script src="libs/topojson-client.min.js"></script>
    <script>
        const svg = d3.select('#map');
        const legendEl = document.getElementById('legend');
        const selectionEl = document.getElementById('selection');
        const statusEl = document.getElementById('status');
        const searchInput = document.getElementById('search');
        const latInput = document.getElementById('lat');
        const lonInput = document.getElementById('lon');
        const geocodeBtn = document.getElementById('geocode');
        const resetBtn = document.getElementById('reset');
        const copyBtn = document.getElementById('copy');
        const datalist = document.getElementById('search-options');

        let projection = d3.geoAlbersUsa().translate([480, 300]).scale(1200);
        let path = d3.geoPath(projection);
        let stateFeatures = [];
        let territoryFeatures = [];
        let addressIndex = [];
        let pointLayer;
        let selectionData = null;

        const formatSelection = (data) => {
            if (!data) return 'Nothing selected yet.';
            const lines = [];
            lines.push(`<div class="pill">${data.kind}</div>`);
            lines.push(`<strong>${data.name}</strong>`);
            if (data.owner) lines.push(`<div class="muted">Owner: ${data.owner}</div>`);
            if (data.note) lines.push(`<div class="muted">Note: ${data.note}</div>`);
            if (data.point) lines.push(`<div class="muted">Point: ${data.point.lat.toFixed(4)}, ${data.point.lon.toFixed(4)}</div>`);
            if (data.label) lines.push(`<div class="muted">Label: ${data.label}</div>`);
            return lines.join('<br>');
        };

        const copySelection = () => {
            if (!selectionData) return;
            const payload = [
                `Type: ${selectionData.kind}`,
                `Name: ${selectionData.name}`,
                selectionData.owner ? `Owner: ${selectionData.owner}` : null,
                selectionData.note ? `Note: ${selectionData.note}` : null,
                selectionData.label ? `Label: ${selectionData.label}` : null,
                selectionData.point ? `Point: ${selectionData.point.lat}, ${selectionData.point.lon}` : null
            ].filter(Boolean).join('\n');
            navigator.clipboard.writeText(payload).then(() => {
                statusEl.textContent = 'Copied selection to clipboard.';
            });
        };

        const buildLegend = (territories) => {
            const typeColors = new Map();
            territories.forEach(t => {
                if (!typeColors.has(t.properties.type)) typeColors.set(t.properties.type, t.properties.color);
            });
            const ul = document.createElement('ul');
            typeColors.forEach((color, type) => {
                const li = document.createElement('li');
                const swatch = document.createElement('span');
                swatch.className = 'swatch';
                swatch.style.background = color;
                li.appendChild(swatch);
                li.appendChild(document.createTextNode(type));
                ul.appendChild(li);
            });
            legendEl.innerHTML = '<h4>Territory Types</h4>';
            legendEl.appendChild(ul);
        };

        const populateSearch = (territories, addresses) => {
            const options = [];
            territories.forEach(t => options.push(t.properties.name));
            addresses.forEach(a => options.push(a.label));
            datalist.innerHTML = '';
            options.sort().forEach(text => {
                const opt = document.createElement('option');
                opt.value = text;
                datalist.appendChild(opt);
            });
        };

        const clearSelection = () => {
            svg.selectAll('.state').classed('selected', false);
            svg.selectAll('.territory').classed('selected', false);
            svg.selectAll('.point').remove();
            selectionData = null;
            selectionEl.innerHTML = 'Click a state or territory, or search above.';
        };

        const markPoint = (coords) => {
            const [x, y] = projection([coords.lon, coords.lat]) || [];
            if (!x || !y) return;
            pointLayer = svg.append('circle')
                .attr('class', 'point')
                .attr('r', 5)
                .attr('cx', x)
                .attr('cy', y);
        };

        const assignSelection = (data) => {
            selectionData = data;
            selectionEl.innerHTML = formatSelection(data);
        };

        const locateState = (pt) => stateFeatures.find((f) => d3.geoContains(f, pt));
        const locateTerritory = (pt) => territoryFeatures.find((f) => d3.geoContains(f, pt));

        const handleGeocode = () => {
            const query = searchInput.value.trim().toLowerCase();
            const latVal = parseFloat(latInput.value);
            const lonVal = parseFloat(lonInput.value);
            clearSelection();

            if (!query && (isNaN(latVal) || isNaN(lonVal))) {
                statusEl.textContent = 'Enter a search term or lat/lon.';
                return;
            }

            let matchPoint = null;
            if (!isNaN(latVal) && !isNaN(lonVal)) {
                matchPoint = { lat: latVal, lon: lonVal, label: 'Custom point' };
            } else {
                const match = addressIndex.find(a => a.label.toLowerCase().includes(query));
                if (match) {
                    matchPoint = { ...match };
                } else {
                    const territory = territoryFeatures.find(t => t.properties.name.toLowerCase().includes(query));
                    if (territory) {
                        svg.select(`#territory-${territory.properties.id}`).classed('selected', true);
                        assignSelection({
                            kind: 'Territory',
                            name: territory.properties.name,
                            owner: territory.properties.owner,
                            label: territory.properties.label,
                            note: territory.properties.description
                        });
                        statusEl.textContent = 'Jumped to territory.';
                        return;
                    }
                    statusEl.textContent = 'No address match found.';
                    return;
                }
            }

            markPoint(matchPoint);
            const pt = [matchPoint.lon, matchPoint.lat];
            const containingTerritory = locateTerritory(pt);
            const containingState = locateState(pt);

            if (containingState) {
                svg.select(`#state-${containingState.id}`).classed('selected', true);
            }
            if (containingTerritory) {
                svg.select(`#territory-${containingTerritory.properties.id}`).classed('selected', true);
            }

            assignSelection({
                kind: containingTerritory ? 'Territory' : 'State',
                name: containingTerritory ? containingTerritory.properties.name : (containingState?.properties.name || 'Outside coverage'),
                owner: containingTerritory?.properties.owner,
                label: containingTerritory?.properties.label,
                note: matchPoint.note,
                point: { lat: matchPoint.lat, lon: matchPoint.lon }
            });
            statusEl.textContent = 'Located point and highlighted coverage.';
        };

        fetch('data/map-data.json')
            .then(res => res.json())
            .then(data => {
                const states = topojson.feature(data.statesTopojson, data.statesTopojson.objects.states);
                stateFeatures = states.features;
                projection = d3.geoAlbersUsa().fitSize([960, 600], states);
                path = d3.geoPath(projection);

                svg.append('g')
                    .selectAll('path')
                    .data(stateFeatures)
                    .enter()
                    .append('path')
                    .attr('class', 'state')
                    .attr('id', d => `state-${d.id}`)
                    .attr('d', path)
                    .on('click', (event, d) => {
                        svg.selectAll('.selected').classed('selected', false);
                        d3.select(event.currentTarget).classed('selected', true);
                        assignSelection({ kind: 'State', name: d.properties.name });
                    });

                territoryFeatures = data.territories.map(t => ({
                    type: 'Feature',
                    properties: { ...t },
                    geometry: t.geometry
                }));

                svg.append('g')
                    .selectAll('path')
                    .data(territoryFeatures)
                    .enter()
                    .append('path')
                    .attr('class', 'territory')
                    .attr('id', d => `territory-${d.properties.id}`)
                    .attr('fill', d => d.properties.color)
                    .attr('d', path)
                    .on('click', (event, d) => {
                        svg.selectAll('.selected').classed('selected', false);
                        d3.select(event.currentTarget).classed('selected', true);
                        assignSelection({
                            kind: 'Territory',
                            name: d.properties.name,
                            owner: d.properties.owner,
                            label: d.properties.label,
                            note: d.properties.description
                        });
                    });

                svg.append('g')
                    .selectAll('text')
                    .data(territoryFeatures)
                    .enter()
                    .append('text')
                    .attr('class', 'territory-label')
                    .attr('transform', d => `translate(${path.centroid(d)})`)
                    .text(d => d.properties.label);

                buildLegend(territoryFeatures);

                addressIndex = data.geocoder.addresses;
                populateSearch(territoryFeatures, addressIndex);
                statusEl.textContent = `Loaded ${addressIndex.length} geocoder entries.`;
            });

        geocodeBtn.addEventListener('click', handleGeocode);
        resetBtn.addEventListener('click', () => {
            clearSelection();
            statusEl.textContent = 'Reset selections.';
            searchInput.value = '';
            latInput.value = '';
            lonInput.value = '';
        });
        copyBtn.addEventListener('click', copySelection);
    </script>
</body>
</html>
